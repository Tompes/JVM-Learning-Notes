# 1.1 运行时数据区域

> Java虚拟机在执行Java程序的过程中会把内存划分为多个不同的区域，这些区域功用各不相同，且创建和销毁的机制也不尽相同。有的区域随着虚拟机的启动而一直存在，而有的区域则是会随着用户线程的启动与结束而创建和销毁。

## 1.1.1 Java VM 的运行时内存区域划分

JVM 的`运行时`内存区域大致有以下：

* [程序计数器](#1-程序计数器-pc-线程私有)

* [Java虚拟机栈](#2-java虚拟机栈-线程私有)

* [本地方法栈](#3-本地方法栈)

* [Java堆](#4-Java堆)

* [方法区](#5-方法区)
  * [运行时常量池](#6-运行时常量池)

* [直接内存](#7-直接内存)



#### 1. 程序计数器 PC （线程私有）

   ``程序计数器``（Program Counter Register）, 是一块较小的、用于``指示``当前线程所执行``指令``的``行号``的内存空间。其功能和硬件中的程序计数器PC基本一致。

   在Java虚拟机的``概念模型``中，<ins>``字节码解释器``工作时就是通过``改变``PC的``值``来``选取``下一条所需执行的字节码``指令``。</ins>

   程序计数器PC是``程序控制流``的``指示器``, ``分支``、``循环``、``跳转``、``异常处理``和``线程恢复``等等基础功能都需要依赖PC来完成。

   由于<ins>JVM中的多线程是通过线程间轮流切换分配CPU资源的方式来实现</ins>的，即在任意确定时刻，一个CPU单元都只会执行一条线程中的指令。故而，<ins>为了保证线程切换后能恢复到正确的执行位置，``每条线程``都需要有一个``独立``的``程序计数器（PC）``。</ins> 每条线程的PC互不影响，独立存储，这类内存区域可称为“``线程私有内存``”。

   > 注： 
   >
   > * 在JVM中，如果当前线程所执行的字节码指令是一个**Java方法**，PC中存储的值是这个**字节码指令的地址**，若当前线程所执行的是一个**本地（Native）方法**的话，则PC中存储的值应该是**空（undefined）**。
   >
   > * **程序计数器（PC）区域是JVM中唯一没有规定OutOfMemoryError的区域！**

#### 1-程序计数器-pc-线程私有2. Java虚拟机栈 （线程私有）

   

#### 3. 本地方法栈

   

#### 4. ##### Java堆

   

#### 5. 方法区

   

#### 6. 运行时常量池

   

#### 7. 直接内存

   

